name: 'Lighthouse (PR)'

on: deployment_status

concurrency:
  group: lhci-${{ github.event.deployment.id }}
  cancel-in-progress: true

permissions:
  contents: read
  deployments: read
  pull-requests: write
  issues: write

env:
  NODE_VERSION: '22'

jobs:
  lighthouse:
    name: 'Lighthouse CI (Preview)'
    runs-on: ubuntu-latest
    timeout-minutes: 25
    if: |
      github.event.deployment_status.state == 'success' &&
      contains(github.event.deployment.environment, 'leenders-coaching') &&
      !contains(github.event.deployment.environment, 'studio')

    steps:
      - name: 'ðŸ”„ Checkout'
        uses: actions/checkout@v5

      - name: 'ðŸ”§ Setup Node.js'
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: 'ðŸ”— Resolve preview URL (environment_url)'
        id: url
        shell: bash
        run: |
          set -euo pipefail
          url="${{ github.event.deployment_status.environment_url || '' }}"
          if [[ "$url" == *"vercel.com/login"* || "$url" == *"sso-api"* ]]; then
            if [[ "$url" =~ url=([^&]+) ]]; then
              enc="${BASH_REMATCH[1]}"
              url="$(python3 -c "import sys,urllib.parse;print(urllib.parse.unquote(sys.argv[1]))" "$enc")"
            fi
          fi
          [[ "$url" =~ ^https?:// ]] || { echo "No valid environment_url"; exit 1; }
          echo "preview_url=$url" >> "$GITHUB_OUTPUT"

      - name: 'ðŸš€ Run Lighthouse CI'
        id: lhci
        uses: treosh/lighthouse-ci-action@v12
        with:
          urls: |
            ${{ steps.url.outputs.preview_url }}
            ${{ steps.url.outputs.preview_url }}/over-mij
            ${{ steps.url.outputs.preview_url }}/aanpak
            ${{ steps.url.outputs.preview_url }}/coaching
            ${{ steps.url.outputs.preview_url }}/contact
          configPath: packages/leenders-coaching-nl/lighthouserc.ci.cjs
          budgetPath: packages/leenders-coaching-nl/budget.json
          uploadArtifacts: true
          temporaryPublicStorage: true
        env:
          LHCI_FORM_FACTOR: mobile
          LHCI_GITHUB_APP_TOKEN: ${{ secrets.LHCI_GITHUB_APP_TOKEN }}
          VERCEL_AUTOMATION_BYPASS_SECRET: ${{ secrets.VERCEL_AUTOMATION_BYPASS_SECRET }}

      - name: 'ðŸ“Š Parse Lighthouse results'
        id: parse
        if: always()
        shell: bash
        run: |
          set -euo pipefail
          command -v jq >/dev/null 2>&1 || { sudo apt-get update -y >/dev/null 2>&1 && sudo apt-get install -y jq -y >/dev/null 2>&1; }

          results_dir="${{ steps.lhci.outputs.resultsPath }}"
          assertion_file="$results_dir/assertion-results.json"

          # defaults
          echo "errc=0"   >> $GITHUB_OUTPUT
          echo "warnc=0"  >> $GITHUB_OUTPUT
          echo "passc=0"  >> $GITHUB_OUTPUT

          # assertions counts (if file exists)
          if [[ -f "$assertion_file" ]]; then
            errc=$(jq '[.[] | select(.level=="error")] | length' "$assertion_file")
            warnc=$(jq '[.[] | select(.level=="warn")]  | length' "$assertion_file")
            passc=$(jq '[.[] | select(.level=="pass")]  | length' "$assertion_file")
            echo "errc=$errc"  >> $GITHUB_OUTPUT
            echo "warnc=$warnc" >> $GITHUB_OUTPUT
            echo "passc=$passc" >> $GITHUB_OUTPUT
          fi

          # derive category scores from raw LHRs (robust)
          shopt -s nullglob
          lhrs=("$results_dir"/lhr-*.json)
          if [[ ${#lhrs[@]} -eq 0 ]]; then
            echo "perf=N/A" >> $GITHUB_OUTPUT
            echo "a11y=N/A" >> $GITHUB_OUTPUT
            echo "seo=N/A"  >> $GITHUB_OUTPUT
            echo "bp=N/A"   >> $GITHUB_OUTPUT
            echo "overall=âš ï¸ NO RESULTS" >> $GITHUB_OUTPUT
          else
            readarray -t vals < <(jq -s '
              def avg: (length as $n | if $n==0 then null else (add / $n) end);
              {
                perf: (map(try .categories.performance.score catch null) | map(select(.!=null)) | avg),
                a11y: (map(try .categories.accessibility.score catch null) | map(select(.!=null)) | avg),
                seo:  (map(try .categories.seo.score catch null) | map(select(.!=null)) | avg),
                bp:   (map(try .categories["best-practices"].score catch null) | map(select(.!=null)) | avg)
              } | [.perf,.a11y,.seo,.bp] | map(if .==null then "N/A" else . end) | .[]
            ' "${lhrs[@]}")

            to_pct () { awk -v v="$1" 'BEGIN{printf "%.0f", v*100}'; }
            perf="${vals[0]}"; a11y="${vals[1]}"; seo="${vals[2]}"; bp="${vals[3]}"

            [[ "$perf" != "N/A" ]] && echo "perf=$(to_pct "$perf")" >> $GITHUB_OUTPUT || echo "perf=N/A" >> $GITHUB_OUTPUT
            [[ "$a11y" != "N/A" ]] && echo "a11y=$(to_pct "$a11y")" >> $GITHUB_OUTPUT || echo "a11y=N/A" >> $GITHUB_OUTPUT
            [[ "$seo"  != "N/A" ]] && echo "seo=$(to_pct "$seo")"   >> $GITHUB_OUTPUT || echo "seo=N/A"  >> $GITHUB_OUTPUT
            [[ "$bp"   != "N/A" ]] && echo "bp=$(to_pct "$bp")"     >> $GITHUB_OUTPUT || echo "bp=N/A"   >> $GITHUB_OUTPUT

            # overall from assertions if present; else pass
            if [[ -f "$assertion_file" ]] && [[ "${errc:-0}" -gt 0 ]]; then
              echo "overall=âŒ FAILED" >> $GITHUB_OUTPUT
            else
              echo "overall=âœ… PASSED" >> $GITHUB_OUTPUT
            fi
          fi

          # robust link extraction
          links='${{ steps.lhci.outputs.links }}'
          report=""
          if [[ -n "$links" && "$links" != "null" ]]; then
            if echo "$links" | grep -q '^\s*\['; then
              report="$(echo "$links" | jq -r 'first // empty' 2>/dev/null || true)"
            else
              report="$(echo "$links" | head -n1 | tr -d '[:space:]')"
            fi
          fi
          echo "report=$report" >> $GITHUB_OUTPUT

      - name: 'ðŸ§¾ Build per-page table'
        id: table
        if: always()
        shell: bash
        run: |
          set -euo pipefail
          command -v jq >/dev/null 2>&1 || { sudo apt-get update -y >/dev/null 2>&1 && sudo apt-get install -y jq -y >/dev/null 2>&1; }

          results_dir="${{ steps.lhci.outputs.resultsPath }}"
          base="${{ steps.url.outputs.preview_url }}"
          # keep your order
          ordered_urls=("$base" "$base/over-mij" "$base/aanpak" "$base/coaching" "$base/contact")

          # Build URL -> {p,a,s,b} with query/hash/trailing-slash normalization
          scores_json="$(jq -sr '
            # strip ?query and #hash, then trailing slash
            def norm(u):
              if u==null then null else (u | sub("[?#].*$"; "") | sub("/$"; "")) end;
            # prefer finalDisplayedUrl, fall back if needed
            def key(x): norm(x.finalDisplayedUrl // x.finalUrl // x.requestedUrl);
            def avg: (length as $n | if $n==0 then null else (add / $n) end);
            sort_by(key(.))
            | group_by(key(.))
            | map(. as $g | {
                url: ($g | first | key(.)),
                p: ([ $g[] | try .categories.performance.score        catch empty ] | map(select(.!=null)) | avg),
                a: ([ $g[] | try .categories.accessibility.score      catch empty ] | map(select(.!=null)) | avg),
                s: ([ $g[] | try .categories.seo.score                catch empty ] | map(select(.!=null)) | avg),
                b: ([ $g[] | try .categories["best-practices"].score catch empty ] | map(select(.!=null)) | avg)
              })
            | map({ (.url): {p:.p,a:.a,s:.s,b:.b} })
            | add // {}
          ' "$results_dir"/lhr-*.json)"

          fpct() { v="$1"; if [[ "$v" == "null" || -z "$v" ]]; then echo "N/A"; else awk -v n="$v" 'BEGIN{printf "%.0f", n*100}'; fi; }

          # Parse links (object / array / newline list) and normalize root key
          raw_links='${{ steps.lhci.outputs.links }}'
          declare -A url2link=()
          declare -a link_list=()
          if [[ -n "$raw_links" && "$raw_links" != "null" ]]; then
            if echo "$raw_links" | grep -q '^{'; then
              while IFS=$'\t' read -r k v; do
                # normalize: drop ?â€¦/#â€¦ and then trailing slash
                k="${k%%[\?#]*}"
                k="${k%/}"
                url2link["$k"]="$v"
              done < <(printf '%s' "$raw_links" | jq -r 'to_entries[] | [.key,.value] | @tsv')
            elif echo "$raw_links" | grep -q '^\s*\['; then
              mapfile -t link_list < <(printf '%s' "$raw_links" | jq -r '.[]')
            else
              mapfile -t link_list < <(printf '%s\n' "$raw_links")
            fi
          fi

          # Build the markdown table (real newlines)
          table="| Page | Perf | A11y | SEO | BP | Report |"$'\n'"|---|---:|---:|---:|---:|---|"$'\n'
          idx=0
          for u in "${ordered_urls[@]}"; do
            # alt key with/without trailing slash
            if [[ "$u" == */ ]]; then alt="${u%/}"; else alt="$u/"; fi
            key="${u%/}" ; altkey="${alt%/}"

            p=$(jq -r --arg k "$key" --arg a "$altkey" -n --argjson m "$scores_json" '($m[$k].p // $m[$a].p // "null")')
            a=$(jq -r --arg k "$key" --arg a "$altkey" -n --argjson m "$scores_json" '($m[$k].a // $m[$a].a // "null")')
            s=$(jq -r --arg k "$key" --arg a "$altkey" -n --argjson m "$scores_json" '($m[$k].s // $m[$a].s // "null")')
            b=$(jq -r --arg k "$key" --arg a "$altkey" -n --argjson m "$scores_json" '($m[$k].b // $m[$a].b // "null")')

            ps=$(fpct "$p"); as=$(fpct "$a"); ss=$(fpct "$s"); bs=$(fpct "$b")

            link="${url2link[$key]-}"
            [[ -z "$link" ]] && link="${url2link[$altkey]-}"
            if [[ -z "$link" && ${#link_list[@]} -gt 0 ]]; then link="${link_list[$idx]-}"; fi
            [[ -n "$link" ]] && report_cell="[Report]($link)" || report_cell="-"

            table+="| $u | $ps | $as | $ss | $bs | $report_cell |"$'\n'
            idx=$((idx+1))
          done

          # Write as a multiline output (no escaping needed)
          {
            echo "md<<EOF"
            echo "$table"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

      - name: 'ðŸ”Ž Resolve PR number'
        id: pr
        if: always()
        env:
          REPO: ${{ github.repository }}
          SHA: ${{ github.event.deployment.sha }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: bash
        run: |
          set -euo pipefail
          command -v jq >/dev/null 2>&1 || { sudo apt-get update -y >/dev/null 2>&1 && sudo apt-get install -y jq >/dev/null 2>&1; }
          json=$(curl -sS -H "Authorization: token ${GH_TOKEN}" -H "Accept: application/vnd.github+json" \
                 "https://api.github.com/repos/${REPO}/commits/${SHA}/pulls")
          pr=$(echo "$json" | jq -r 'map(select(.state!="closed")) | first | .number // empty')
          echo "number=$pr" >> $GITHUB_OUTPUT
          [[ -n "$pr" ]] && echo "Found PR #$pr" || echo "No open PR found for $SHA"

      - name: 'ðŸ’¬ Sticky Lighthouse comment'
        if: always() && steps.pr.outputs.number != ''
        uses: marocchino/sticky-pull-request-comment@v2
        with:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          header: lighthouse-report
          number: ${{ steps.pr.outputs.number }}
          message: |
            ## ðŸš€ Lighthouse Performance Report
            **Preview URL:** ${{ steps.url.outputs.preview_url }}
            **Status:** ${{ steps.parse.outputs.overall }}

            ${{ steps.table.outputs.md }}

            **Assertions:** âœ… ${{ steps.parse.outputs.passc }} Â· âš ï¸ ${{ steps.parse.outputs.warnc }} Â· âŒ ${{ steps.parse.outputs.errc }}

      - name: 'ðŸ“‹ Job summary'
        if: always()
        shell: bash
        run: |
          {
            echo "## ðŸš€ Lighthouse (Preview)";
            echo "- URL: ${{ steps.url.outputs.preview_url }}";
            echo "- Status: ${{ steps.parse.outputs.overall }}";
            echo "";
            echo "${{ steps.table.outputs.md }}";
            echo "";
            echo "**Assertions:** âœ… ${{ steps.parse.outputs.passc }} Â· âš ï¸ ${{ steps.parse.outputs.warnc }} Â· âŒ ${{ steps.parse.outputs.errc }}";
          } >> $GITHUB_STEP_SUMMARY
