name: 'Lighthouse (Production)'

on:
  push:
    branches: [main]
    paths-ignore: ['**.md', 'docs/**']
  workflow_dispatch:
  schedule:
    - cron: '0 5 * * *'

concurrency:
  group: lhci-main
  cancel-in-progress: true

permissions:
  contents: read
  issues: write

jobs:
  # Setup environment
  setup:
    runs-on: ubuntu-latest
    steps:
      - name: 'Checkout code'
        uses: actions/checkout@v5
      - name: '⚙️ Setup Environment'
        uses: ./.github/actions/setup
        with:
          node-version: '22'
          pnpm-version: '10.15.1'
          working-directory: ''

  lighthouse:
    name: 'Lighthouse CI (Production) – ${{ matrix.formFactor }}'
    runs-on: ubuntu-latest
    needs: setup
    timeout-minutes: 20
    strategy:
      matrix:
        formFactor: [mobile, desktop]

    steps:
      - name: '🔄 Checkout repository'
        uses: actions/checkout@v5
        with:
          fetch-depth: 1

      - name: '🧪 Test production URL accessibility'
        run: |
          urls=( "https://leenders-coaching.vercel.app/"
                 "https://leenders-coaching.vercel.app/over-mij"
                 "https://leenders-coaching.vercel.app/aanpak"
                 "https://leenders-coaching.vercel.app/coaching"
                 "https://leenders-coaching.vercel.app/contact" )

          echo "🔍 Testing production URL accessibility for all pages:"
          for production_url in "${urls[@]}"; do
            echo "  Testing: $production_url"
            response=$(curl -sL --max-time 30 --max-redirs 5 "$production_url" || echo "CURL_FAILED")
            if [[ "$response" == "CURL_FAILED" ]]; then
              echo "❌ Production URL is not accessible (network error)"
              echo "   URL: $production_url"
              exit 1
            else
              code=$(curl -s -o /dev/null -w "%{http_code}" "$production_url")
              if [[ "$code" -ge 200 ]] && [[ "$code" -lt 400 ]]; then
                echo "✅ HTTP $code - accessible"
              else
                echo "⚠️ Production URL returns HTTP $code"
                echo "   URL: $production_url"
                exit 1
              fi
            fi
          done
          echo "🎯 All production pages are accessible and ready for Lighthouse testing"

      - name: '🚀 Run Lighthouse CI (Production)'
        id: lhci
        uses: treosh/lighthouse-ci-action@v12
        with:
          urls: |
            https://leenders-coaching.vercel.app/
            https://leenders-coaching.vercel.app/over-mij
            https://leenders-coaching.vercel.app/aanpak
            https://leenders-coaching.vercel.app/coaching
            https://leenders-coaching.vercel.app/contact
          configPath: packages/leenders-coaching-nl/lighthouserc.ci.cjs
          budgetPath: packages/leenders-coaching-nl/budget.json
          uploadArtifacts: true
          artifactName: lighthouse-${{ matrix.formFactor }}
          temporaryPublicStorage: true
        env:
          LHCI_GITHUB_APP_TOKEN: ${{ secrets.LHCI_GITHUB_APP_TOKEN }}
          LHCI_FORM_FACTOR: ${{ matrix.formFactor }}

      - name: '📊 Parse & summarize Lighthouse results'
        id: parse
        if: always()
        shell: bash
        run: |
          set -euo pipefail
          sudo apt-get update -y >/dev/null 2>&1 || true
          sudo apt-get install -y jq >/dev/null 2>&1 || true

          results_dir="${{ steps.lhci.outputs.resultsPath }}"
          shopt -s nullglob
          lhrs=("$results_dir"/lhr-*.json)

          # ----- Extract environment metadata from first LHR -----
          if [[ ${#lhrs[@]} -gt 0 ]]; then
            env_md=$(jq -r '
              {
                lighthouseVersion: .lighthouseVersion,
                userAgent: .userAgent,
                emulatedFormFactor: .configSettings.emulatedFormFactor,
                throttling: .configSettings.throttling
              } as $e
              | "**Lighthouse**: \($e.lighthouseVersion // "n/a")\n"
                + "**User-Agent**: \($e.userAgent // "n/a")\n"
                + "**Emulated form factor**: \($e.emulatedFormFactor // "n/a")\n"
                + "**Throttling**: RTT=\($e.throttling.rttMs // "n/a")ms, "
                + "Throughput=\($e.throttling.throughputKbps // "n/a")kbps, "
                + "CPU×\($e.throttling.cpuSlowdownMultiplier // "n/a")"
            ' "${lhrs[0]}")
          else
            env_md="_No Lighthouse result files were found (lhr-*.json)._"
          fi

          # ----- Averages across all runs -----
          if [[ ${#lhrs[@]} -gt 0 ]]; then
            readarray -t agg < <(jq -s '
              def avg: (length as $n | if $n==0 then null else (add / $n) end);
              {
                perf: (map(try .categories.performance.score catch null) | map(select(.!=null)) | avg),
                a11y: (map(try .categories.accessibility.score catch null) | map(select(.!=null)) | avg),
                seo:  (map(try .categories.seo.score catch null) | map(select(.!=null)) | avg),
                bp:   (map(try .categories["best-practices"].score catch null) | map(select(.!=null)) | avg)
              } | [.perf,.a11y,.seo,.bp] | map(if .==null then "N/A" else . end) | .[]
            ' "${lhrs[@]}")
          fi

          fmt100() { if [[ "$1" == "N/A" ]]; then echo "N/A"; else awk -v v="$1" 'BEGIN{printf "%.0f/100", v*100}'; fi; }
          avg_perf="$(fmt100 "${agg[0]:-N/A}")"
          avg_a11y="$(fmt100 "${agg[1]:-N/A}")"
          avg_seo="$(fmt100 "${agg[2]:-N/A}")"
          avg_bp="$(fmt100 "${agg[3]:-N/A}")"

          # ----- Per-page category rows (averaged by final URL) -----
          rows_md=$(
            if [[ ${#lhrs[@]} -gt 0 ]]; then
              jq -s -r '
                def norm(u): if u==null then null else (u | sub("[?#].*$"; "") | sub("/$"; "")) end;
                def key(x): norm(x.finalDisplayedUrl // x.finalUrl // x.requestedUrl);
                def avg: (length as $n | if $n==0 then null else (add / $n) end);
                group_by(key(.)) |
                map(. as $g |
                  {
                    url: ($g | first | key(.)),
                    p: ([ $g[] | try .categories.performance.score catch empty ] | map(select(.!=null)) | avg),
                    a: ([ $g[] | try .categories.accessibility.score catch empty ] | map(select(.!=null)) | avg),
                    s: ([ $g[] | try .categories.seo.score catch empty ] | map(select(.!=null)) | avg),
                    b: ([ $g[] | try .categories["best-practices"].score catch empty ] | map(select(.!=null)) | avg)
                  }
                )
                | sort_by(.url)
                | map("| \(.url) | " +
                      (if .p then ((.p*100)|tostring) else "N/A" end) + " | " +
                      (if .a then ((.a*100)|tostring) else "N/A" end) + " | " +
                      (if .s then ((.s*100)|tostring) else "N/A" end) + " | " +
                      (if .b then ((.b*100)|tostring) else "N/A" end) + " |")[]
              ' "${lhrs[@]}"
            fi
          )

          # ----- Robust link extraction -----
          links_raw='${{ steps.lhci.outputs.links }}'
          declare -A url2link=()
          declare -a link_list=()
          if [[ -n "$links_raw" && "$links_raw" != "null" ]]; then
            if echo "$links_raw" | grep -q '^{'; then
              while IFS=$'\t' read -r k v; do
                k="${k%%[\?#]*}"; k="${k%/}"
                url2link["$k"]="$v"
              done < <(printf '%s' "$links_raw" | jq -r 'to_entries[] | [.key,.value] | @tsv')
            elif echo "$links_raw" | grep -q '^\s*\['; then
              mapfile -t link_list < <(printf '%s' "$links_raw" | jq -r '.[]')
            else
              mapfile -t link_list < <(printf '%s\n' "$links_raw")
            fi
          fi

          # ----- Attach report links to categories table -----
          i=0
          table="| Page | Perf | A11y | SEO | BP | Report |"$'\n'"|---|---:|---:|---:|---:|---|"$'\n'
          while IFS= read -r row; do
            [[ -z "$row" ]] && continue
            row_url=$(echo "$row" | sed 's/^| \([^|]*\) |.*/\1/')
            key="${row_url%/}"
            if [[ "$row_url" == */ ]]; then altkey="${row_url%/}"; else altkey="$row_url/"; fi
            link="${url2link[$key]-}"
            [[ -z "$link" ]] && link="${url2link[$altkey]-}"
            if [[ -z "$link" && ${#link_list[@]} -gt 0 ]]; then link="${link_list[$i]-}"; fi
            link="${link%%[[:space:]]*}"
            [[ -n "$link" ]] && report_cell="[Report](${link})" || report_cell="-"
            table+="${row} ${report_cell} |"$'\n'
            i=$((i+1))
          done <<< "$rows_md"

          # ----- Vitals per page (averaged) -----
          vitals_table="| Page | LCP (ms) | CLS | TBT (ms) | FCP (ms) | SI (ms) | TTI (ms) | Req | Bytes (KB) |"$'\n'"|---|---:|---:|---:|---:|---:|---:|---:|---:|"$'\n'
          if [[ ${#lhrs[@]} -gt 0 ]]; then
            vitals_rows=$(jq -s -r '
              def norm(u): if u==null then null else (u | sub("[?#].*$"; "") | sub("/$"; "")) end;
              def key(x): norm(x.finalDisplayedUrl // x.finalUrl // x.requestedUrl);
              def avg: (length as $n | if $n==0 then null else (add / $n) end);
              group_by(key(.)) |
              map(. as $g |
                {
                  url: ($g | first | key(.)),
                  lcp: ([ $g[] | try .audits["largest-contentful-paint"].numericValue catch empty ] | map(select(.!=null)) | avg),
                  cls: ([ $g[] | try .audits["cumulative-layout-shift"].numericValue catch empty ] | map(select(.!=null)) | avg),
                  tbt: ([ $g[] | try .audits["total-blocking-time"].numericValue catch empty ] | map(select(.!=null)) | avg),
                  fcp: ([ $g[] | try .audits["first-contentful-paint"].numericValue catch empty ] | map(select(.!=null)) | avg),
                  si:  ([ $g[] | try .audits["speed-index"].numericValue catch empty ] | map(select(.!=null)) | avg),
                  tti: ([ $g[] | try .audits["interactive"].numericValue catch empty ] | map(select(.!=null)) | avg),
                  bytes: ([ $g[] | try .audits["total-byte-weight"].numericValue catch empty ] | map(select(.!=null)) | avg),
                  reqs: ([ $g[] | try (.audits["network-requests"].details.items | length) catch empty ] | map(select(.!=null)) | avg)
                }
              )
              | sort_by(.url)
              | map("| \(.url) | " +
                    (if .lcp then (.lcp|tostring) else "N/A" end) + " | " +
                    (if .cls then (.cls|tostring) else "N/A" end) + " | " +
                    (if .tbt then (.tbt|tostring) else "N/A" end) + " | " +
                    (if .fcp then (.fcp|tostring) else "N/A" end) + " | " +
                    (if .si  then (.si|tostring)  else "N/A" end) + " | " +
                    (if .tti then (.tti|tostring) else "N/A" end) + " | " +
                    (if .reqs then (.reqs|tostring) else "N/A" end) + " | " +
                    (if .bytes then (.bytes/1024|floor|tostring) else "N/A" end) + " |")[]
            ' "${lhrs[@]}")
            vitals_table+="$vitals_rows"$'\n'
          fi

          # ----- First report link (quick access) -----
          first_link=""
          if [[ ${#link_list[@]} -gt 0 ]]; then
            first_link="${link_list[0]-}"
          elif [[ ${#url2link[@]} -gt 0 ]]; then
            first_link=$(printf '%s\n' "${url2link[@]}" | head -n1)
          fi

          # ----- Assertions (if available) -----
          assertion_file="$results_dir/assertion-results.json"
          if [[ -f "$assertion_file" ]]; then
            rows=$(jq -r '
              [ .[] | select(.level!="pass")
                | { level, id: (.id // .auditId // "—"),
                    url: (.url // "—"),
                    op: (.result.operator // "—"),
                    exp: (.result.expected // "—"),
                    act: (.result.actual // "—") } ]
              | .[:30]
              | map("| \(.level) | \(.id) | \(.exp) | \(.act) | \(.op) | \(.url) |")
              | .[]
            ' "$assertion_file")
            assert_md="| Level | Check | Expected | Actual | Operator | URL |\n|---|---|---|---|---|---|\n"
            if [[ -n "$rows" ]]; then
              printf '%s\n' "$rows" >> temp_assertions.md
              assert_md+=$(cat temp_assertions.md)
              rm -f temp_assertions.md
            else
              assert_md+="| - | - | - | - | - | - |\n"
            fi
          else
            assert_md="_No assertions file found._"
          fi

          # ----- Write Job Summary -----
          {
            echo "## 🚀 Production Lighthouse – ${{ matrix.formFactor }}";
            echo "";
            echo "**Averages (all pages/runs):**";
            echo "";
            echo "| Category | Score |";
            echo "|---|---|";
            echo "| Performance | ${avg_perf} |";
            echo "| Accessibility | ${avg_a11y} |";
            echo "| SEO | ${avg_seo} |";
            echo "| Best Practices | ${avg_bp} |";
            echo "";
            echo "### Category Scores";
            echo "${table}";
            if [[ -n "$first_link" ]]; then
              echo "";
              echo "- Temporary public report (first page): ${first_link}";
            fi
            echo "";
            echo "### Core Metrics";
            echo "${vitals_table}";
            echo "";
            echo "### Assertion details";
            echo "";
            echo "<br/>";
            echo "";
            echo "${assert_md}";
          } >> $GITHUB_STEP_SUMMARY

          # ----- Add attribution to job summary -----
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "*Generated by GitHub Actions Lighthouse (Production)*" >> $GITHUB_STEP_SUMMARY

          # ----- Expose outputs for issue body -----
          {
            echo "averages_md<<EOF"
            echo "| Category | Score |"
            echo "|---|---|"
            echo "| Performance | ${avg_perf} |"
            echo "| Accessibility | ${avg_a11y} |"
            echo "| SEO | ${avg_seo} |"
            echo "| Best Practices | ${avg_bp} |"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

          {
            echo "categories_table_md<<EOF"
            echo "${table}"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

          {
            echo "vitals_table_md<<EOF"
            echo "${vitals_table}"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

          {
            echo "assertions_md<<EOF"
            echo "${assert_md}"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

          {
            echo "env_md<<EOF"
            echo "${env_md}"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

          echo "first_report_link=${first_link}" >> "$GITHUB_OUTPUT"

      - name: '🚨 Open regression issue when failed'
        if: failure() && github.event_name != 'schedule'
        uses: actions/github-script@v7
        env:
          FIRST_REPORT: ${{ steps.parse.outputs.first_report_link }}
          AVERAGES_MD: ${{ steps.parse.outputs.averages_md }}
          CATEGORIES_TABLE_MD: ${{ steps.parse.outputs.categories_table_md }}
          VITALS_TABLE_MD: ${{ steps.parse.outputs.vitals_table_md }}
          ASSERTIONS_MD: ${{ steps.parse.outputs.assertions_md }}
          ENV_MD: ${{ steps.parse.outputs.env_md }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const firstReport = (process.env.FIRST_REPORT || '').trim();
            const averagesMd = process.env.AVERAGES_MD || '';
            const categoriesTableMd = process.env.CATEGORIES_TABLE_MD || '';
            const vitalsTableMd = process.env.VITALS_TABLE_MD || '';
            const assertionsMd = process.env.ASSERTIONS_MD || '';
            const envMd = process.env.ENV_MD || '';

            const title = 'Lighthouse regression on main – ${{ matrix.formFactor }} (' + new Date().toISOString().slice(0,10) + ')';

            const body = '**Form factor:** `${{ matrix.formFactor }}`\n\n' +
              '**Commit:** `${{ github.sha }}`\n' +
              '**Run:** https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}\n' +
              (firstReport ? '**First report:** ' + firstReport + '\n' : '') +
              '\n---\n\n' +
              '### Averages (all pages/runs)\n' +
              averagesMd + '\n\n' +
              '---\n\n' +
              '### Category Scores\n' +
              categoriesTableMd + '\n\n' +
              '---\n\n' +
              '### Core Metrics\n' +
              vitalsTableMd + '\n\n' +
              '---\n\n' +
              '### Assertion details\n' +
              '\n<br/>\n\n' +
              assertionsMd + '\n\n' +
              '---\n\n' +
              '### Environment\n' +
              envMd + '\n\n' +
              '---\n\n' +
              '*Generated by GitHub Actions Lighthouse (Production)*';

            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title,
              body,
              labels: ['performance','lighthouse','regression']
            });
